package org.codingtest.set;

import java.util.HashSet;

public class 영어_끝말잇기 {

    /*  1부터 n까지 번호가 붙어 있는 n명의 사람이 영어 끝말잇기를 합니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.
    *       1. 1번부터 번호 순서대로 한 사람씩 단어를 말합니다.
    *       2. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.
    *       3. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.
    *       4. 이전에 등장했던 단어는 사용할 수 없습니다.
    *       5. 한 글자인 단어는 인정되지 않습니다.
    *   다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.
    *       * tank -> kick -> know -> wheel -> land -> dream -> mother -> robot -> tank
    *   위 끝말잇기는 다음과 같이 진행됩니다.
    *       * 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.
    *       * 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.
    *       * 3번 사람이 자신의 첫 번째 차례에 know를 말합니다.
    *       * 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.
    *       * (계속 진행)
    *   끝말잇기를 계속 진행하다 보면 3번 사람이 말한 tank는 이전에 등장했던 단어이므로 탈락합니다. 사람의 수 n과 사람들이 순서대로 말한
    *   단어 words가 매개변수로 주어질 때 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락했는지 반환하는 solution()
    *   함수를 완성 해주세요.
    *
    *   - 제약 조건
    *   1. 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.
    *   2. words는 끝말잇기에 사용한 단어들이 순서대로 들어 있는 배열이며, 길이는 n 이상 100 이하입니다.
    *   3. 단어의 길이는 2 이상 50 이하입니다.
    *   4. 모든 단어는 알파벳 소문자로만 이루어져 있습니다.
    *   5. 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않아도 됩니다.
    *   6. 정답은 [번호, 차례] 형태로 반환해주세요.
    *   7. 만약 주어진 단어들로 탈락자가 생기지 않는다면 [0, 0]을 반환하세요.
    *
    *   - 시간 복잡도 분석
    *   N은 words의 길이입니다. words의 길이만큼 반복문을 순회하고 각 연산의 시간 복잡도는 O(1)이므로 최종 시간 복잡도는 O(N)입니다.
    */
    public static int[] solution(int n, String[] words) {
        // 1. 이미 사용한 단어를 저장하는 set
        HashSet<String> usedWords = new HashSet<>();
        // 2. 이전 단어의 마지막 글자, 최초 상태는 첫 번째 사람이 말하는 첫 번째 글자로 초기화
        char prevWord = words[0].charAt(0);

        for (int i = 0; i < words.length; i++) {
            // 3. 이미 사용한 단어이거나 첫 글자가 이전 단어와 일치하지 않으면
            if (usedWords.contains(words[i]) || words[i].charAt(0) != prevWord) {
                // 4. 탈락하는 사람의 번호와 차례를 반환
                return new int[]{(i % n) +1, (i / n) + 1};
            }
            // 5. 사용한 단어로 추가
            usedWords.add(words[i]);
            // 6. 이전 단어의 마지막 글자 업데이트
            prevWord = words[i].charAt(words[i].length() - 1);
        }
        // 7. 모두 통과했을 경우 반환 값
        return new int[]{0, 0};
    }
}