package org.codingtest.simulation;

import java.util.HashMap;
import java.util.HashSet;

public class 롤케이크_자르기 {

    /*  철수는 롤케이크를 두 조각으로 잘라서 동생과 한 조각씩 나눠먹으려고 합니다. 롤케이크에는 여러 가지 토핑이 올려져 있습니다. 그런데
     *  철수와 동생은 롤케이크의 크기보다 롤케이크 위에 올려진 토핑 종류에 관심이 더 많습니다. 그래서 잘린 조각의 크기와 조각 위의 토핑 개수에
     *  상관없이 각 조각에 동일한 가짓수의 토핑이 올라가면 공평하게 롤케이크가 나누어진 것으로 생각합니다.
     *  예를 들어 롤케이크에 네 종류의 토핑이 올려져 있다고 합시다. 토핑을 1, 2, 3, 4와 같은 번호로 표시했을 때 케잍크 위에 토핑이
     *  [1, 2, 1, 3, 1, 4, 1, 2] 순서로 올려져 있고, 세 번째 토핑(1)과 네 번째 토핑(3) 사이를 자르면 롤케이크의 토핑은 [1, 2, 1],
     *  [3, 1, 4, 1, 2]로 나뉩니다. 그리고 철수가 [1, 2, 1] 조각을, 동생이 [3, 1, 4, 1, 2] 조각을 먹으면 철수는 두 가지 토핑(1, 2)
     *  을 맛볼 수 있지만 동생은 네 가지 토핑(1, 2, 3, 4)을 맛볼 수 있으므로 이는 공평하지 않습니다. 만약 네 번째 토핑(3)과 다섯 번째
     *  토핑(1) 사이를 자르면 [1, 2, 1, 3], [1, 4, 1, 2]로 나뉘므로 철수는 세 가지 토핑(1, 2, 3)을 동생도 세 가지 토핑(1, 2, 4)을
     *  맛볼 수 있으므로 이는 공평합니다. 공평하게 롤케이크를 자르는 방법은 하나 이상일 수 있습니다. 예를 들어 [1, 2, 1, 3, 1], [4, 1, 2]
     *  으로 잘라도 공평합니다. 어떤 경우에는 롤케이크를 공평하게 나누지 못할 수도 있습니다.
     *  롤케이크에 올려진 토핑의 번호를 저장한 정수 배열 topping이 주어질 때 롤케이크를 공평하게 자르는 방법의 수를 반환하는 solution()
     *  함수를 완성하세요.
     *
     *   - 제약 조건
     *   1. 1 <= topping의 길이 <= 1,000,000
     *   2. 1 <= topping의 원소 <= 10,000
     *
     *   - 시간 복잡도 분석
     *   N은 topping의 길이입니다. topping의 길이만큼 반복문을 수행하므로 시간 복잡도는 O(N)입니다. 참고로 내부 연산들은 모두 O(1)입니다.
     *   따라서 최종 시간 복잡도는 O(N)입니다.
     */

    public static int solution(int[] topping) {
        // 1. 결과값을 저장할 변수 초기화
        int answer = 0;
        // 2. 토핑의 개수를 세어서 해시맵에 저장
        HashMap<Integer, Integer> toppingMap = new HashMap<>();
        for (int t : topping) {
            toppingMap.put(t, toppingMap.getOrDefault(t, 0) + 1);
        }

        // 3. 토핑의 종류를 저장할 해시셋
        HashSet<Integer> toppingSet = new HashSet<>();

        // 4. 롤케이크를 하나씩 해시셋에 넣으면서 확인
        for (int t : topping) {
            // 5. 해시셋에 토핑을 추가하고, 해당 토핑의 전체 개수를 해시맵에서 줄임
            toppingSet.add(t);
            toppingMap.put(t, toppingMap.get(t) - 1);

            // 6. 토핑의 전체 개수가 0이면 해시맵에서 제거
            if (toppingMap.get(t) == 0) {
                toppingMap.remove(t);
            }

            // 7. 토핑의 종류의 수가 같다면
            if (toppingSet.size() == toppingMap.size()) {
                answer++;
            }
        }

        // 8. 공평하게 나눌 수 있는 방법의 수 반환
        return answer;
    }
}